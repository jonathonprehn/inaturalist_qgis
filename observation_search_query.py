# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Obesrvation, ObservationSearchQuery
                                 A QGIS plugin
 Facilitates data retrieval from iNaturalist directly into QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-02-03
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Jonathon Prehn
        email                : 
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys 
import json 
import requests
import urllib.parse
import math
import abc 

from qgis.core import (
    QgsApplication,
    QgsMessageLog,
    Qgis
)

from .abstract_search_query import INaturalistSearchQuery


class ObservationSearchQuery(INaturalistSearchQuery):

    # TODO:
    # - search and paginate observations from a query
    # - make UI components for this in INaturalistUserPluginDockWidget

    def __init__(self, apiRoot):

        self.apiRoot = apiRoot
        self.acc = None   # Whether or not positional accuracy / coordinate uncertainty has been specified
        self.captive = None   # Captive or cultivated observations
        self.endemic = None   # Observations whose taxa are endemic to their location
        self.geo = None   # Observations that are georeferenced
        self.id_please = None   # Observations with the deprecated ID, Please! flag. Note that this will return observations, but that this attribute is no longer used.
        self.identified = None   # Observations that have community identifications
        self.introduced = None   # Observations whose taxa are introduced in their location
        self.mappable = None   # Observations that show on map tiles
        self.native = None   # Observations whose taxa are native to their location
        self.out_of_range = None   # Observations whose taxa are outside their known ranges
        self.pcid = None   # Observations identified by the curator of a project. If the project_id parameter is also specified, this will only consider observations identified by curators of the specified project(s)
        self.photos = None   # Observations with photos
        self.popular = None   # Observations that have been favorited by at least one user
        self.sounds = None   # Observations with sounds
        self.taxon_is_active = None   # Observations of active taxon concepts
        self.threatened = None   # Observations whose taxa are threatened in their location
        self.verifiable = None   # Observations with a quality_grade of either needs_id or research. Equivalent to quality_grade=needs_id,research
        self.licensed = None   # License attribute of an observation must not be null
        self.photo_licensed = None   # License attribute of at least one photo of an observation must not be null
        self.id = []   # Must have this ID
        self.not_id = []   # Must not have this ID
        self.license = []   # Observation must have this license
        self.ofv_datatype = []   # Must have an observation field value with this datatype
        self.photo_license = []   # Must have at least one photo with this license
        self.place_id = []   # Must be observed within the place with this ID
        self.project_id = []   # Must be added to the project this ID or slug
        self.rank = []   # Taxon must have this rank
        self.site_id = []   # Must be affiliated with the iNaturalist network website with this ID
        self.sound_license = []   # Must have at least one sound with this license
        self.taxon_id = []   # Only show observations of these taxa and their descendants
        self.without_taxon_id = []   # Exclude observations of these taxa and their descendants
        self.taxon_name = []   # Taxon must have a scientific or common name matching this string
        self.user_id = []   # User must have this ID or login
        self.user_login = []   # User must have this login
        self.ident_user_id = None   # Observations identified by a particular user
        self.day = []   # Must be observed within this day of the month
        self.month = []   # Must be observed within this month
        self.year = []   # Must be observed within this year
        self.term_id = []   # Must have an annotation using this controlled term ID
        self.term_value_id = []   # Must have an annotation using this controlled value ID. Must be combined with the term_id parameter
        self.without_term_id = None   # Exclude observations with annotations using this controlled value ID.
        self.without_term_value_id = []   # Exclude observations with annotations using this controlled value ID. Must be combined with the term_id parameter
        self.acc_above = None   # Must have a positional accuracy above this value (meters)
        self.acc_below = None   # Must have a positional accuracy below this value (meters)
        self.acc_below_or_unknown = None   # Positional accuracy must be below this value (in meters) or be unknown
        self.d1 = None   # Must be observed on or after this date
        self.d2 = None   # Must be observed on or before this date
        self.created_d1 = None   # Must be created at or after this time
        self.created_d2 = None   # Must be created at or before this time
        self.created_on = None   # Must be created on this date
        self.observed_on = None   # Must be observed on this date
        self.unobserved_by_user_id = None   # Must not be of a taxon previously observed by this user
        self.apply_project_rules_for = ''   # Must match the rules of the project with this ID or slug
        self.cs = None   # Taxon must have this conservation status code. If the place_id parameter is also specified, this will only consider statuses specific to that place
        self.csa = None   # Taxon must have a conservation status from this authority. If the place_id parameter is also specified, this will only consider statuses specific to that place
        self.csi = []   # Taxon must have this IUCN conservation status. If the place_id parameter is also specified, this will only consider statuses specific to that place
        self.geoprivacy = []   # Must have this geoprivacy setting
        self.taxon_geoprivacy = []   # Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
        self.hrank = None   # Taxon must have this rank or lower
        self.lrank = None   # Taxon must have this rank or higher
        self.iconic_taxa = []   # Taxon must by within this iconic taxon
        self.id_above = None   # Must have an ID above this value
        self.id_below = None   # Must have an ID below this value
        self.identifications = None   # Identifications must meet these criteria
        self.lat = None   # Must be within a {radius} kilometer circle around this lat/lng (lat, lng, radius)
        self.lng = None   # Must be within a {radius} kilometer circle around this lat/lng (lat, lng, radius)
        self.radius = None   # Must be within a {radius} kilometer circle around this lat/lng (lat, lng, radius)
        self.nelat = None   # Must be within this bounding box (nelat, nelng, swlat, swlng)
        self.nelng = None   # Must be within this bounding box (nelat, nelng, swlat, swlng)
        self.swlat = None   # Must be within this bounding box (nelat, nelng, swlat, swlng)
        self.swlng = None   # Must be within this bounding box (nelat, nelng, swlat, swlng)
        self.list_id = None   # Taxon must be in the list with this ID
        self.not_in_project = None   # Must not be in the project with this ID or slug
        self.not_matching_project_rules_for = None   # Must not match the rules of the project with this ID or slug
        self.q = None   # Search observation properties. Can be combined with search_on
        self.search_on = None   # Properties to search on, when combined with q. Searches across all properties by default
        self.quality_grade = None   # Must have this quality grade
        self.updated_since = None   # Must be updated since this time
        self.viewer_id = None   # See reviewed
        self.reviewed = None   # Observations have been reviewed by the user with ID equal to the value of the viewer_id parameter
        self.locale = None   # Locale preference for taxon common names
        self.preferred_place_id = None   # Place preference for regional taxon common names
        self.ttl = None   # Set the Cache-Control HTTP header with this value as max-age, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
        self.page = 1   # Pagination page number
        self.per_page = 20   # Number of results to return in a page. The maximum value is generally 200 unless otherwise noted
        self.order = 'desc'   # Sort order
        self.order_by = 'created_at'   # Sort field
        self.only_id = False   # Return only the record IDs

        self.last_response_obj = None
        self.last_response_err = None
        


    def last_query_error(self):
        # whether there was an error in processing 
        return self.last_response_err


    # use this to know what page you're on
    def query_page_number(self):
        if self.last_query_error() is None and self.last_response_obj is not None:
            return self.last_response_obj["page"]
        else:
            return None


    # use this to know how many pages there are, for iteration
    def query_max_pages(self):
        if self.last_query_error() is None and self.last_response_obj is not None:
            total_results = self.last_response_obj["total_results"]
            per_page = self.last_response_obj["per_page"]
            return int(math.ceil(float(total_results)/float(per_page)))
        else:
            return None
        
    
    def query_total_results(self):
        if self.last_query_error() is None and self.last_response_obj is not None:
            return self.last_response_obj["total_results"]
        else:
            return None

    def get_current_page_results(self):
        # convert the last query to a list of observations 
        if self.last_query_error() is None and self.last_response_obj is not None:
            results = self.last_response_obj["results"]
            # no need to convert this to an object, it's already a nice Python dictionary to work with
            return results
        else:
            return []

    
    def next_page(self):
        if self.last_query_error() is None and self.last_response_obj is not None:
            if self.page < self.query_max_pages():
                self.page = self.page + 1
                return True
            else:
                return False
        else:
            return False


    def prev_page(self):
        if self.last_query_error() is None and self.last_response_obj is not None:
            if self.page > 1:
                self.page = self.page - 1
                return True
            else:
                return False
        else:
            return False


    def query(self):


        # used this to help with generating the code below
        #for field in fields:
        #    if field[1] == 'None':
        #        code = code + 'if self.' + field[0] + ' is not None:\n    pass\n'
        #    elif field[1] == '[]':
        #        code = code + 'if len(self.'+field[0]+') > 0:\n    pass\n'
        #    else:
        #        code = code + 'if self.'+field[0]+':\n    pass\n'
        try:

            query_params = dict()


            if self.acc is not None:
                raise Exception("Property not implemented")
            
            if self.captive is not None:
                raise Exception("Property not implemented")
            
            if self.endemic is not None:
                raise Exception("Property not implemented")
            
            if self.geo is not None:
                raise Exception("Property not implemented")
            
            if self.id_please is not None:
                raise Exception("Property not implemented")
            
            if self.identified is not None:
                raise Exception("Property not implemented")
            
            if self.introduced is not None:
                raise Exception("Property not implemented")
            
            if self.mappable is not None:
                raise Exception("Property not implemented")
            
            if self.native is not None:
                raise Exception("Property not implemented")
            
            if self.out_of_range is not None:
                raise Exception("Property not implemented")
            
            if self.pcid is not None:
                raise Exception("Property not implemented")
            
            if self.photos is not None:
                raise Exception("Property not implemented")
            
            if self.popular is not None:
                raise Exception("Property not implemented")
            
            if self.sounds is not None:
                raise Exception("Property not implemented")
            
            if self.taxon_is_active is not None:
                raise Exception("Property not implemented")
            
            if self.threatened is not None:
                raise Exception("Property not implemented")
            
            if self.verifiable is not None:
                raise Exception("Property not implemented")
            
            if self.licensed is not None:
                raise Exception("Property not implemented")
            
            if self.photo_licensed is not None:
                raise Exception("Property not implemented")
            
            if len(self.id) > 0:
                raise Exception("Property not implemented")
            
            if len(self.not_id) > 0:
                raise Exception("Property not implemented")
            
            if len(self.license) > 0:
                raise Exception("Property not implemented")
            
            if len(self.ofv_datatype) > 0:
                raise Exception("Property not implemented")
            
            if len(self.photo_license) > 0:
                raise Exception("Property not implemented")
            
            if len(self.place_id) > 0:
                raise Exception("Property not implemented")
            
            if len(self.project_id) > 0:
                raise Exception("Property not implemented")
            
            if len(self.rank) > 0:
                raise Exception("Property not implemented")
            
            if len(self.site_id) > 0:
                raise Exception("Property not implemented")
            
            if len(self.sound_license) > 0:
                raise Exception("Property not implemented")
            
            if len(self.taxon_id) > 0:
                raise Exception("Property not implemented")
            
            if len(self.without_taxon_id) > 0:
                raise Exception("Property not implemented")
            
            if len(self.taxon_name) > 0:
                raise Exception("Property not implemented")
            
            if len(self.user_id) > 0:
                raise Exception("Property not implemented")
            
            if len(self.user_login) > 0:
                raise Exception("Property not implemented")
            
            if self.ident_user_id is not None:
                raise Exception("Property not implemented")
            
            if len(self.day) > 0:
                raise Exception("Property not implemented")
            
            if len(self.month) > 0:
                raise Exception("Property not implemented")
            
            if len(self.year) > 0:
                raise Exception("Property not implemented")
            
            if len(self.term_id) > 0:
                raise Exception("Property not implemented")
            
            if len(self.term_value_id) > 0:
                raise Exception("Property not implemented")
            
            if self.without_term_id is not None:
                raise Exception("Property not implemented")
            
            if len(self.without_term_value_id) > 0:
                raise Exception("Property not implemented")
            
            if self.acc_above is not None:
                raise Exception("Property not implemented")
            
            if self.acc_below is not None:
                raise Exception("Property not implemented")
            
            if self.acc_below_or_unknown is not None:
                raise Exception("Property not implemented")
            
            if self.d1 is not None:
                raise Exception("Property not implemented")
            
            if self.d2 is not None:
                raise Exception("Property not implemented")
            
            if self.created_d1 is not None:
                raise Exception("Property not implemented")
            
            if self.created_d2 is not None:
                raise Exception("Property not implemented")
            
            if self.created_on is not None:
                raise Exception("Property not implemented")
            
            if self.observed_on is not None:
                raise Exception("Property not implemented")
            
            if self.unobserved_by_user_id is not None:
                raise Exception("Property not implemented")
            
            if self.apply_project_rules_for:
                raise Exception("Property not implemented")
            
            if self.cs is not None:
                raise Exception("Property not implemented")
            
            if self.csa is not None:
                raise Exception("Property not implemented")
            
            if len(self.csi) > 0:
                raise Exception("Property not implemented")
            
            if len(self.geoprivacy) > 0:
                raise Exception("Property not implemented")
            
            if len(self.taxon_geoprivacy) > 0:
                raise Exception("Property not implemented")
            
            if self.hrank is not None:
                raise Exception("Property not implemented")
            
            if self.lrank is not None:
                raise Exception("Property not implemented")
            
            if len(self.iconic_taxa) > 0:
                raise Exception("Property not implemented")
            
            if self.id_above is not None:
                raise Exception("Property not implemented")
            
            if self.id_below is not None:
                raise Exception("Property not implemented")
            
            if self.identifications is not None:
                raise Exception("Property not implemented")
            
            if self.lat is not None:
                raise Exception("Property not implemented")
            
            if self.lng is not None:
                raise Exception("Property not implemented")
            
            if self.radius is not None:
                raise Exception("Property not implemented")
            
            
            if self.nelat is not None:
                raise Exception("Property not implemented")
            
            if self.nelng is not None:
                raise Exception("Property not implemented")
            
            if self.swlat is not None:
                raise Exception("Property not implemented")
            
            if self.swlng is not None:
                raise Exception("Property not implemented")
            
            if self.list_id is not None:
                raise Exception("Property not implemented")
            
            if self.not_in_project is not None:
                raise Exception("Property not implemented")
            
            if self.not_matching_project_rules_for is not None:
                raise Exception("Property not implemented")
            
            if self.q is not None:
                query_params["q"] = self.q

            if self.search_on is not None:
                raise Exception("Property not implemented")
            
            if self.quality_grade is not None:
                raise Exception("Property not implemented")
            
            if self.updated_since is not None:
                raise Exception("Property not implemented")
            
            if self.viewer_id is not None:
                raise Exception("Property not implemented")
            
            if self.reviewed is not None:
                raise Exception("Property not implemented")
            
            if self.locale is not None:
                raise Exception("Property not implemented")
            
            if self.preferred_place_id is not None:
                raise Exception("Property not implemented")
            
            if self.ttl is not None:
                raise Exception("Property not implemented")
            
            query_params["page"] = self.page
            query_params["per_page"] = self.per_page

            if self.order is None:
                self.order = "desc"
            query_params["order"] = self.order

            if self.order_by is None:
                self.order_by = "created_at"
            query_params["order_by"] = self.order_by

            if self.only_id:
                raise Exception("Property not implemented")

            params_string = "&".join([str(k) + "=" + str(query_params[k]) for k in query_params])
            api_call = self.apiRoot + "/observations" + "?" + params_string # self.apiRoot should end with /
            # QgsApplication.instance().messageLog().logMessage(api_call)

            # response = requests.get(self.apiRoot, query_params)
            QgsApplication.instance().messageLog().logMessage("get url is", level=Qgis.Info)
            QgsApplication.instance().messageLog().logMessage(str(api_call), level=Qgis.Info)

            r = requests.get(url=api_call);
            
            # dump results 
            dump_to = os.path.join(os.path.dirname(__file__), "last_query_result.json")
            with open(dump_to, "w") as fp:
                json_txt = str(r.text)
                fp.write(json.dumps(json.loads(json_txt), indent=2))
            
            obj = r.json()
            if r.status_code == 200:
                # all good
                self.last_response_obj = obj
                self.last_response_err = None
            else:
                if "error" in obj:
                    self.last_query_error = obj["error"]
                else:
                    self.last_query_error = "Error when querying. Response status " + str(r.status_code)

            return obj
        
        except Exception as e:
            QgsApplication.instance().messageLog().logMessage(str(api_call), level=Qgis.Critical)
            QgsApplication.instance().messageLog().logMessage("Exception is", level=Qgis.Critical)
            QgsApplication.instance().messageLog().logMessage(str(e), level=Qgis.Critical)
            self.last_response_err = e
            self.last_response_obj = None
            return None



